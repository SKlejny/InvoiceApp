{"ast":null,"code":"// src/services/sharepointService.js\n\nimport { SHAREPOINT_SITE_ID, SHAREPOINT_DRIVE_ID, INCOMING_INVOICES_FOLDER_ITEM_ID, APPROVED_INVOICES_FOLDER_ITEM_ID, PUBLISHED_DOCUMENTS_FOLDER_ITEM_ID, SENT_FOLDER_ITEM_ID, FOLDER_NAMES } from '../utils/constants';\nimport { loginRequest } from '../authConfig';\nimport { InteractionRequiredAuthError } from '@azure/msal-browser'; // Corrected import syntax\n\nconst getAccessToken = async (instance, accounts) => {\n  if (!instance || !accounts || accounts.length === 0) {\n    throw new Error(\"No active MSAL account found.\");\n  }\n  try {\n    const response = await instance.acquireTokenSilent({\n      ...loginRequest,\n      account: accounts[0]\n    });\n    return response.accessToken;\n  } catch (error) {\n    if (error instanceof InteractionRequiredAuthError) {\n      await instance.acquireTokenPopup(loginRequest);\n      const response = await instance.acquireTokenSilent({\n        ...loginRequest,\n        account: accounts[0]\n      });\n      return response.accessToken;\n    }\n    throw error;\n  }\n};\nconst getSharePointBaseUrl = () => {\n  return `https://graph.microsoft.com/v1.0/sites/${SHAREPOINT_SITE_ID}/drives/${SHAREPOINT_DRIVE_ID}/items`;\n};\n\n/**\n * Determines the file type based on file extension and MIME type.\n * @param {string} fileName The name of the file.\n * @param {string} [mimeType] The MIME type of the file (optional).\n * @returns {string} 'pdf', 'xlsx', 'image', or 'other'.\n */\nconst getFileType = (fileName, mimeType) => {\n  if (fileName.toLowerCase().endsWith('.pdf')) {\n    return 'pdf';\n  } else if (fileName.toLowerCase().endsWith('.xlsx')) {\n    return 'xlsx';\n  } else if (mimeType && mimeType.startsWith('image/')) {\n    return 'image';\n  }\n  return 'other';\n};\nexport const fetchSharePointFiles = async (instance, accounts) => {\n  const accessToken = await getAccessToken(instance, accounts);\n  const baseUrl = getSharePointBaseUrl();\n  const folderMap = {\n    [FOLDER_NAMES.INCOMING_INVOICES]: INCOMING_INVOICES_FOLDER_ITEM_ID,\n    [FOLDER_NAMES.APPROVED_INVOICES]: APPROVED_INVOICES_FOLDER_ITEM_ID,\n    [FOLDER_NAMES.PUBLISHED_DOCUMENTS]: PUBLISHED_DOCUMENTS_FOLDER_ITEM_ID,\n    [FOLDER_NAMES.SENT_DOCUMENTS]: SENT_FOLDER_ITEM_ID\n  };\n  const allFoldersData = {};\n  for (const folderName in folderMap) {\n    const folderItemId = folderMap[folderName];\n    const url = `${baseUrl}/${folderItemId}/children`;\n    try {\n      const response = await fetch(url, {\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status} for ${folderName}`);\n      }\n      const data = await response.json();\n      allFoldersData[folderName] = data.value\n      // Filter 1: Keep only items that are files (have a 'file' property), exclude folders.\n      .filter(item => item.file)\n      // Map to your desired file object format, determining the type.\n      .map(item => {\n        var _item$file, _item$file2;\n        const fileType = getFileType(item.name, (_item$file = item.file) === null || _item$file === void 0 ? void 0 : _item$file.mimeType);\n        return {\n          id: item.id,\n          name: item.name,\n          type: fileType,\n          // Use the determined type\n          webUrl: item.webUrl,\n          downloadUrl: item[\"@microsoft.graph.downloadUrl\"],\n          eTag: item.eTag,\n          mimeType: (_item$file2 = item.file) === null || _item$file2 === void 0 ? void 0 : _item$file2.mimeType\n        };\n      })\n      // Filter 2: Keep only files that are 'pdf' or 'xlsx' type.\n      .filter(file => file.type === 'pdf' || file.type === 'xlsx');\n    } catch (error) {\n      console.error(`Failed to fetch files for ${folderName}:`, error);\n      allFoldersData[folderName] = [];\n      throw error; // Re-throw to ensure App.js knows about the error\n    }\n  }\n  return allFoldersData;\n};\nexport const uploadFileToSharePoint = async (file, folderItemId, instance, accounts) => {\n  const accessToken = await getAccessToken(instance, accounts);\n  const baseUrl = getSharePointBaseUrl();\n  const url = `${baseUrl}/${folderItemId}:/${file.name}:/content`;\n  try {\n    const response = await fetch(url, {\n      method: 'PUT',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': file.type\n      },\n      body: file\n    });\n    if (!response.ok) {\n      var _errorData$error;\n      const errorData = await response.json();\n      throw new Error(`Failed to upload file: ${response.status} ${response.statusText} - ${((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || 'Unknown error'}`);\n    }\n    const data = await response.json();\n    console.log('File uploaded successfully:', data);\n    return data;\n  } catch (error) {\n    console.error('Error uploading file:', error);\n    throw error;\n  }\n};\nexport const downloadFileFromSharePoint = async (fileItem, instance, accounts) => {\n  if (fileItem.type === 'xlsx' && fileItem.webUrl) {\n    // For Excel, SharePoint automatically opens in Excel Online.\n    // The \"View\" button for XLSX will open the webUrl in a new tab.\n    window.open(fileItem.webUrl, '_blank');\n    return null; // No content to return for in-app viewing\n  }\n  const accessToken = await getAccessToken(instance, accounts);\n  if (!fileItem.downloadUrl) {\n    throw new Error('No download URL available for this file.');\n  }\n  try {\n    var _fileItem$mimeType;\n    const response = await fetch(fileItem.downloadUrl, {\n      headers: {\n        'Authorization': `Bearer ${accessToken}`\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to download file: ${response.status} ${response.statusText}`);\n    }\n    if (fileItem.type === 'pdf' || (_fileItem$mimeType = fileItem.mimeType) !== null && _fileItem$mimeType !== void 0 && _fileItem$mimeType.startsWith('image/')) {\n      const blob = await response.blob();\n      return URL.createObjectURL(blob);\n    } else {\n      return await response.text();\n    }\n  } catch (error) {\n    console.error('Error downloading file:', error);\n    throw error;\n  }\n};\nexport const updateSharePointFileContent = async (fileId, newFileName, newContent, instance, accounts) => {\n  const accessToken = await getAccessToken(instance, accounts);\n  const baseUrl = getSharePointBaseUrl();\n  const fileUrl = `${baseUrl}/${fileId}`;\n\n  // For simplicity, we'll try to update directly. If SharePoint requires ETag for PUT content,\n  // this might need adjustment to first GET the item to get the latest ETag.\n  const contentUrl = `${fileUrl}/content`;\n  try {\n    const contentResponse = await fetch(contentUrl, {\n      method: 'PUT',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'text/plain',\n        // Assuming text content for editing\n        'If-Match': '*' // Use '*' to overwrite unconditionally, or provide item.eTag\n      },\n      body: newContent\n    });\n    if (!contentResponse.ok) {\n      var _errorData$error2;\n      const errorData = await contentResponse.json();\n      throw new Error(`Failed to update file content: ${contentResponse.status} ${contentResponse.statusText} - ${((_errorData$error2 = errorData.error) === null || _errorData$error2 === void 0 ? void 0 : _errorData$error2.message) || 'Unknown error'}`);\n    }\n\n    // After content, update metadata (like name) if it changed\n    if (newFileName) {\n      const renameUrl = `${fileUrl}`;\n      const renameResponse = await fetch(renameUrl, {\n        method: 'PATCH',\n        // PATCH for metadata updates\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n          'If-Match': '*' // Use '*' for unconditional update of metadata\n        },\n        body: JSON.stringify({\n          name: newFileName\n        })\n      });\n      if (!renameResponse.ok) {\n        var _errorData$error3;\n        const errorData = await renameResponse.json();\n        throw new Error(`Failed to rename file: ${renameResponse.status} ${renameResponse.statusText} - ${((_errorData$error3 = errorData.error) === null || _errorData$error3 === void 0 ? void 0 : _errorData$error3.message) || 'Unknown error'}`);\n      }\n    }\n    console.log('File updated successfully (content and/or name)');\n    return true;\n  } catch (error) {\n    console.error('Error updating file:', error);\n    throw error;\n  }\n};\nexport const moveSharePointFile = async (fileId, sourceFolderId, destinationFolderId, instance, accounts) => {\n  const accessToken = await getAccessToken(instance, accounts);\n  const baseUrl = getSharePointBaseUrl();\n  const url = `${baseUrl}/${fileId}`;\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      // Use PATCH for moving/renaming items\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'If-Match': '*' // Required for move operations\n      },\n      body: JSON.stringify({\n        parentReference: {\n          driveId: SHAREPOINT_DRIVE_ID,\n          // Use the global DRIVE_ID for moves within the same drive\n          id: destinationFolderId\n        }\n      })\n    });\n    if (!response.ok) {\n      var _errorData$error4;\n      const errorData = await response.json();\n      throw new Error(`Failed to move file: ${response.status} ${response.statusText} - ${((_errorData$error4 = errorData.error) === null || _errorData$error4 === void 0 ? void 0 : _errorData$error4.message) || 'Unknown error'}`);\n    }\n    const data = await response.json();\n    console.log('File moved successfully:', data);\n    return data;\n  } catch (error) {\n    console.error('Error moving file:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["SHAREPOINT_SITE_ID","SHAREPOINT_DRIVE_ID","INCOMING_INVOICES_FOLDER_ITEM_ID","APPROVED_INVOICES_FOLDER_ITEM_ID","PUBLISHED_DOCUMENTS_FOLDER_ITEM_ID","SENT_FOLDER_ITEM_ID","FOLDER_NAMES","loginRequest","InteractionRequiredAuthError","getAccessToken","instance","accounts","length","Error","response","acquireTokenSilent","account","accessToken","error","acquireTokenPopup","getSharePointBaseUrl","getFileType","fileName","mimeType","toLowerCase","endsWith","startsWith","fetchSharePointFiles","baseUrl","folderMap","INCOMING_INVOICES","APPROVED_INVOICES","PUBLISHED_DOCUMENTS","SENT_DOCUMENTS","allFoldersData","folderName","folderItemId","url","fetch","headers","ok","status","data","json","value","filter","item","file","map","_item$file","_item$file2","fileType","name","id","type","webUrl","downloadUrl","eTag","console","uploadFileToSharePoint","method","body","_errorData$error","errorData","statusText","message","log","downloadFileFromSharePoint","fileItem","window","open","_fileItem$mimeType","blob","URL","createObjectURL","text","updateSharePointFileContent","fileId","newFileName","newContent","fileUrl","contentUrl","contentResponse","_errorData$error2","renameUrl","renameResponse","JSON","stringify","_errorData$error3","moveSharePointFile","sourceFolderId","destinationFolderId","parentReference","driveId","_errorData$error4"],"sources":["/workspaces/InvoiceApp/src/services/sharepointService.js"],"sourcesContent":["// src/services/sharepointService.js\n\nimport {\n  SHAREPOINT_SITE_ID,\n  SHAREPOINT_DRIVE_ID,\n  INCOMING_INVOICES_FOLDER_ITEM_ID,\n  APPROVED_INVOICES_FOLDER_ITEM_ID,\n  PUBLISHED_DOCUMENTS_FOLDER_ITEM_ID,\n  SENT_FOLDER_ITEM_ID,\n  FOLDER_NAMES\n} from '../utils/constants';\n\nimport { loginRequest } from '../authConfig';\nimport { InteractionRequiredAuthError } from '@azure/msal-browser'; // Corrected import syntax\n\nconst getAccessToken = async (instance, accounts) => {\n  if (!instance || !accounts || accounts.length === 0) {\n    throw new Error(\"No active MSAL account found.\");\n  }\n  try {\n    const response = await instance.acquireTokenSilent({\n      ...loginRequest,\n      account: accounts[0]\n    });\n    return response.accessToken;\n  } catch (error) {\n    if (error instanceof InteractionRequiredAuthError) {\n      await instance.acquireTokenPopup(loginRequest);\n      const response = await instance.acquireTokenSilent({\n        ...loginRequest,\n        account: accounts[0]\n      });\n      return response.accessToken;\n    }\n    throw error;\n  }\n};\n\nconst getSharePointBaseUrl = () => {\n  return `https://graph.microsoft.com/v1.0/sites/${SHAREPOINT_SITE_ID}/drives/${SHAREPOINT_DRIVE_ID}/items`;\n};\n\n/**\n * Determines the file type based on file extension and MIME type.\n * @param {string} fileName The name of the file.\n * @param {string} [mimeType] The MIME type of the file (optional).\n * @returns {string} 'pdf', 'xlsx', 'image', or 'other'.\n */\nconst getFileType = (fileName, mimeType) => {\n  if (fileName.toLowerCase().endsWith('.pdf')) {\n    return 'pdf';\n  } else if (fileName.toLowerCase().endsWith('.xlsx')) {\n    return 'xlsx';\n  } else if (mimeType && mimeType.startsWith('image/')) {\n    return 'image';\n  }\n  return 'other';\n};\n\nexport const fetchSharePointFiles = async (instance, accounts) => {\n  const accessToken = await getAccessToken(instance, accounts);\n  const baseUrl = getSharePointBaseUrl();\n\n  const folderMap = {\n    [FOLDER_NAMES.INCOMING_INVOICES]: INCOMING_INVOICES_FOLDER_ITEM_ID,\n    [FOLDER_NAMES.APPROVED_INVOICES]: APPROVED_INVOICES_FOLDER_ITEM_ID,\n    [FOLDER_NAMES.PUBLISHED_DOCUMENTS]: PUBLISHED_DOCUMENTS_FOLDER_ITEM_ID,\n    [FOLDER_NAMES.SENT_DOCUMENTS]: SENT_FOLDER_ITEM_ID,\n  };\n\n  const allFoldersData = {};\n\n  for (const folderName in folderMap) {\n    const folderItemId = folderMap[folderName];\n    const url = `${baseUrl}/${folderItemId}/children`;\n    try {\n      const response = await fetch(url, {\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status} for ${folderName}`);\n      }\n      const data = await response.json();\n\n      allFoldersData[folderName] = data.value\n        // Filter 1: Keep only items that are files (have a 'file' property), exclude folders.\n        .filter(item => item.file)\n        // Map to your desired file object format, determining the type.\n        .map(item => {\n          const fileType = getFileType(item.name, item.file?.mimeType);\n          return {\n            id: item.id,\n            name: item.name,\n            type: fileType, // Use the determined type\n            webUrl: item.webUrl,\n            downloadUrl: item[\"@microsoft.graph.downloadUrl\"],\n            eTag: item.eTag,\n            mimeType: item.file?.mimeType,\n          };\n        })\n        // Filter 2: Keep only files that are 'pdf' or 'xlsx' type.\n        .filter(file => file.type === 'pdf' || file.type === 'xlsx');\n\n    } catch (error) {\n      console.error(`Failed to fetch files for ${folderName}:`, error);\n      allFoldersData[folderName] = [];\n      throw error; // Re-throw to ensure App.js knows about the error\n    }\n  }\n  return allFoldersData;\n};\n\nexport const uploadFileToSharePoint = async (file, folderItemId, instance, accounts) => {\n  const accessToken = await getAccessToken(instance, accounts);\n  const baseUrl = getSharePointBaseUrl();\n  const url = `${baseUrl}/${folderItemId}:/${file.name}:/content`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'PUT',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': file.type,\n      },\n      body: file\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(`Failed to upload file: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);\n    }\n\n    const data = await response.json();\n    console.log('File uploaded successfully:', data);\n    return data;\n  } catch (error) {\n    console.error('Error uploading file:', error);\n    throw error;\n  }\n};\n\nexport const downloadFileFromSharePoint = async (fileItem, instance, accounts) => {\n  if (fileItem.type === 'xlsx' && fileItem.webUrl) {\n    // For Excel, SharePoint automatically opens in Excel Online.\n    // The \"View\" button for XLSX will open the webUrl in a new tab.\n    window.open(fileItem.webUrl, '_blank');\n    return null; // No content to return for in-app viewing\n  }\n\n  const accessToken = await getAccessToken(instance, accounts);\n  if (!fileItem.downloadUrl) {\n    throw new Error('No download URL available for this file.');\n  }\n\n  try {\n    const response = await fetch(fileItem.downloadUrl, {\n      headers: {\n        'Authorization': `Bearer ${accessToken}`\n      }\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to download file: ${response.status} ${response.statusText}`);\n    }\n\n    if (fileItem.type === 'pdf' || fileItem.mimeType?.startsWith('image/')) {\n        const blob = await response.blob();\n        return URL.createObjectURL(blob);\n    } else {\n        return await response.text();\n    }\n  } catch (error) {\n    console.error('Error downloading file:', error);\n    throw error;\n  }\n};\n\nexport const updateSharePointFileContent = async (fileId, newFileName, newContent, instance, accounts) => {\n  const accessToken = await getAccessToken(instance, accounts);\n  const baseUrl = getSharePointBaseUrl();\n\n  const fileUrl = `${baseUrl}/${fileId}`;\n\n  // For simplicity, we'll try to update directly. If SharePoint requires ETag for PUT content,\n  // this might need adjustment to first GET the item to get the latest ETag.\n  const contentUrl = `${fileUrl}/content`;\n\n  try {\n    const contentResponse = await fetch(contentUrl, {\n      method: 'PUT',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'text/plain', // Assuming text content for editing\n        'If-Match': '*', // Use '*' to overwrite unconditionally, or provide item.eTag\n      },\n      body: newContent,\n    });\n\n    if (!contentResponse.ok) {\n      const errorData = await contentResponse.json();\n      throw new Error(`Failed to update file content: ${contentResponse.status} ${contentResponse.statusText} - ${errorData.error?.message || 'Unknown error'}`);\n    }\n\n    // After content, update metadata (like name) if it changed\n    if (newFileName) {\n      const renameUrl = `${fileUrl}`;\n      const renameResponse = await fetch(renameUrl, {\n        method: 'PATCH', // PATCH for metadata updates\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n          'If-Match': '*', // Use '*' for unconditional update of metadata\n        },\n        body: JSON.stringify({ name: newFileName }),\n      });\n\n      if (!renameResponse.ok) {\n        const errorData = await renameResponse.json();\n        throw new Error(`Failed to rename file: ${renameResponse.status} ${renameResponse.statusText} - ${errorData.error?.message || 'Unknown error'}`);\n      }\n    }\n\n    console.log('File updated successfully (content and/or name)');\n    return true;\n  } catch (error) {\n    console.error('Error updating file:', error);\n    throw error;\n  }\n};\n\nexport const moveSharePointFile = async (fileId, sourceFolderId, destinationFolderId, instance, accounts) => {\n  const accessToken = await getAccessToken(instance, accounts);\n  const baseUrl = getSharePointBaseUrl();\n  const url = `${baseUrl}/${fileId}`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH', // Use PATCH for moving/renaming items\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'If-Match': '*' // Required for move operations\n      },\n      body: JSON.stringify({\n        parentReference: {\n          driveId: SHAREPOINT_DRIVE_ID, // Use the global DRIVE_ID for moves within the same drive\n          id: destinationFolderId,\n        }\n      })\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(`Failed to move file: ${response.status} ${response.statusText} - ${errorData.error?.message || 'Unknown error'}`);\n    }\n\n    const data = await response.json();\n    console.log('File moved successfully:', data);\n    return data;\n  } catch (error) {\n    console.error('Error moving file:', error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}