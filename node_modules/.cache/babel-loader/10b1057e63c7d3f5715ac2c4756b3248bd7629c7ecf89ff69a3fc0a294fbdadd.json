{"ast":null,"code":"// src/services/sharepointService.js\nimport { SHAREPOINT_SITE_ID, SHAREPOINT_DRIVE_ID } from '../utils/constants';\nimport { loginRequest } from '../authConfig';\nimport { InteractionRequiredAuthError } from '@azure/msal-browser';\n\n/**\n * Acquires an access token from MSAL, handling interactive popups if needed.\n * This is the single source of truth for getting a token.\n */\nexport const getAccessToken = async (instance, accounts) => {\n  if (!instance || !accounts || accounts.length === 0) {\n    throw new Error(\"MSAL instance or accounts not available.\");\n  }\n  const request = {\n    ...loginRequest,\n    account: accounts[0]\n  };\n  try {\n    const response = await instance.acquireTokenSilent(request);\n    return response.accessToken;\n  } catch (error) {\n    if (error instanceof InteractionRequiredAuthError) {\n      const response = await instance.acquireTokenPopup(request);\n      return response.accessToken;\n    }\n    throw error;\n  }\n};\n\n/**\n * Fetches the list of files from a specific SharePoint folder.\n * @param {string} accessToken - The authenticated access token.\n * @param {string} folderId - The ID of the SharePoint folder.\n * @returns {Promise<Array>} A promise that resolves to an array of file items.\n */\nexport const fetchFilesFromFolder = async (accessToken, folderId) => {\n  const url = `https://graph.microsoft.com/v1.0/sites/${SHAREPOINT_SITE_ID}/drives/${SHAREPOINT_DRIVE_ID}/items/${folderId}/children`;\n  const response = await fetch(url, {\n    headers: {\n      'Authorization': `Bearer ${accessToken}`\n    }\n  });\n  if (!response.ok) throw new Error(`Failed to fetch files from folder ${folderId}`);\n  const data = await response.json();\n  // Map to a consistent file object format\n  return data.value.filter(item => item.file) // Ensure we only process files, not folders\n  .map(item => ({\n    id: item.id,\n    name: item.name,\n    webUrl: item.webUrl,\n    downloadUrl: item[\"@microsoft.graph.downloadUrl\"],\n    createdDateTime: item.createdDateTime,\n    type: item.name.toLowerCase().endsWith('.xlsx') ? 'xlsx' : 'pdf' // Simple type detection\n  }));\n};\n\n/**\n * Moves a file from one SharePoint folder to another.\n * @param {string} accessToken - The authenticated access token.\n * @param {string} fileId - The ID of the file to move.\n * @param {string} destinationFolderId - The ID of the target folder.\n */\nexport const moveFile = async (accessToken, fileId, destinationFolderId) => {\n  const url = `https://graph.microsoft.com/v1.0/sites/${SHAREPOINT_SITE_ID}/drives/${SHAREPOINT_DRIVE_ID}/items/${fileId}`;\n  const body = {\n    parentReference: {\n      id: destinationFolderId\n    }\n  };\n  const response = await fetch(url, {\n    method: 'PATCH',\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(body)\n  });\n  if (!response.ok) throw new Error('Failed to move file.');\n};\n\n/**\n * Downloads the content of a file. For PDFs, it returns a blob URL.\n * @param {string} accessToken - The authenticated access token.\n * @param {object} file - The file object, containing its downloadUrl.\n * @returns {Promise<string>} A promise that resolves to the file content or a blob URL.\n */\nexport const downloadFileContent = async (accessToken, file) => {\n  if (!file.downloadUrl) throw new Error(\"File has no download URL.\");\n  const response = await fetch(file.downloadUrl, {\n    headers: {\n      'Authorization': `Bearer ${accessToken}`\n    }\n  });\n  if (!response.ok) throw new Error('Failed to download file content.');\n\n  // For PDFs and other viewable types, create a blob URL to render in an iframe\n  if (file.type === 'pdf') {\n    const blob = await response.blob();\n    return URL.createObjectURL(blob);\n  }\n\n  // For other types, you might return text or handle differently\n  return await response.text();\n};","map":{"version":3,"names":["SHAREPOINT_SITE_ID","SHAREPOINT_DRIVE_ID","loginRequest","InteractionRequiredAuthError","getAccessToken","instance","accounts","length","Error","request","account","response","acquireTokenSilent","accessToken","error","acquireTokenPopup","fetchFilesFromFolder","folderId","url","fetch","headers","ok","data","json","value","filter","item","file","map","id","name","webUrl","downloadUrl","createdDateTime","type","toLowerCase","endsWith","moveFile","fileId","destinationFolderId","body","parentReference","method","JSON","stringify","downloadFileContent","blob","URL","createObjectURL","text"],"sources":["/workspaces/InvoiceApp/src/services/sharepointService.js"],"sourcesContent":["// src/services/sharepointService.js\nimport { SHAREPOINT_SITE_ID, SHAREPOINT_DRIVE_ID } from '../utils/constants';\nimport { loginRequest } from '../authConfig';\nimport { InteractionRequiredAuthError } from '@azure/msal-browser';\n\n/**\n * Acquires an access token from MSAL, handling interactive popups if needed.\n * This is the single source of truth for getting a token.\n */\nexport const getAccessToken = async (instance, accounts) => {\n  if (!instance || !accounts || accounts.length === 0) {\n    throw new Error(\"MSAL instance or accounts not available.\");\n  }\n  const request = { ...loginRequest, account: accounts[0] };\n\n  try {\n    const response = await instance.acquireTokenSilent(request);\n    return response.accessToken;\n  } catch (error) {\n    if (error instanceof InteractionRequiredAuthError) {\n      const response = await instance.acquireTokenPopup(request);\n      return response.accessToken;\n    }\n    throw error;\n  }\n};\n\n/**\n * Fetches the list of files from a specific SharePoint folder.\n * @param {string} accessToken - The authenticated access token.\n * @param {string} folderId - The ID of the SharePoint folder.\n * @returns {Promise<Array>} A promise that resolves to an array of file items.\n */\nexport const fetchFilesFromFolder = async (accessToken, folderId) => {\n  const url = `https://graph.microsoft.com/v1.0/sites/${SHAREPOINT_SITE_ID}/drives/${SHAREPOINT_DRIVE_ID}/items/${folderId}/children`;\n  \n  const response = await fetch(url, {\n    headers: { 'Authorization': `Bearer ${accessToken}` }\n  });\n\n  if (!response.ok) throw new Error(`Failed to fetch files from folder ${folderId}`);\n  \n  const data = await response.json();\n  // Map to a consistent file object format\n  return data.value\n    .filter(item => item.file) // Ensure we only process files, not folders\n    .map(item => ({\n      id: item.id,\n      name: item.name,\n      webUrl: item.webUrl,\n      downloadUrl: item[\"@microsoft.graph.downloadUrl\"],\n      createdDateTime: item.createdDateTime,\n      type: item.name.toLowerCase().endsWith('.xlsx') ? 'xlsx' : 'pdf', // Simple type detection\n    }));\n};\n\n/**\n * Moves a file from one SharePoint folder to another.\n * @param {string} accessToken - The authenticated access token.\n * @param {string} fileId - The ID of the file to move.\n * @param {string} destinationFolderId - The ID of the target folder.\n */\nexport const moveFile = async (accessToken, fileId, destinationFolderId) => {\n  const url = `https://graph.microsoft.com/v1.0/sites/${SHAREPOINT_SITE_ID}/drives/${SHAREPOINT_DRIVE_ID}/items/${fileId}`;\n  \n  const body = {\n    parentReference: { id: destinationFolderId }\n  };\n\n  const response = await fetch(url, {\n    method: 'PATCH',\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(body)\n  });\n\n  if (!response.ok) throw new Error('Failed to move file.');\n};\n\n/**\n * Downloads the content of a file. For PDFs, it returns a blob URL.\n * @param {string} accessToken - The authenticated access token.\n * @param {object} file - The file object, containing its downloadUrl.\n * @returns {Promise<string>} A promise that resolves to the file content or a blob URL.\n */\nexport const downloadFileContent = async (accessToken, file) => {\n  if (!file.downloadUrl) throw new Error(\"File has no download URL.\");\n\n  const response = await fetch(file.downloadUrl, {\n    headers: { 'Authorization': `Bearer ${accessToken}` }\n  });\n\n  if (!response.ok) throw new Error('Failed to download file content.');\n\n  // For PDFs and other viewable types, create a blob URL to render in an iframe\n  if (file.type === 'pdf') {\n      const blob = await response.blob();\n      return URL.createObjectURL(blob);\n  }\n\n  // For other types, you might return text or handle differently\n  return await response.text();\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}